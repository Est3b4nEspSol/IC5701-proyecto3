package generated;
import java_cup.runtime.*;
import Sintactico.*;
import java.io.FileWriter;
import java.io.IOException;

parser code {:
    Lexer lex;
    SymTable symtab = new SymTable();
    ArbolSintactico arbol;
    String currentFunctionReturnType = null;
    int insideLoop = 0;
    boolean oneMain = false;
    int errorCount = 0;

    private String[] currentForLabels = null;
    private int forIncrementCodeStart = -1;
    private int forBlockCodeStart = -1;
    private String savedIncrementCode = null;
    private int currentTemp = 0;
    private int frameSize = 0;

    private StringBuffer textSection = new StringBuffer();
    private StringBuffer dataSection = new StringBuffer();
    private int labelCounter = 0;
    private boolean dataSectionGenerated = false;
    private boolean textSectionGenerated = false;

    public String newTemp() {
        String temp = "$t" + (currentTemp % 10);
        currentTemp++;
        return temp;
    }

    public void gen(String instruction) {
        textSection.append(instruction).append("\n");
    }

    public void initTextSection() {
        if (!textSectionGenerated) {
            String textSectionCode = ".text\n" +
                                    ".globl main\n" +
                                    "main:\n" +
                                    "    jal navidad\n" +
                                    "    li $v0, 10\n" +
                                    "    syscall\n";

            textSection.insert(0, textSectionCode);

            textSectionGenerated = true;
        }
    }

        public void genData(String label, String directive) {
            if (!dataSectionGenerated) {
                dataSection.append(".data\n");
                dataSectionGenerated = true;
            }

            dataSection.append(label).append(": ").append(directive).append("\n");
        }

    public void allocateVariable(String variable) {
        SymInfo sym = symtab.lookup(variable);
        if (sym == null) {
            System.err.println("Error: Variable '" + variable + "' no encontrada");
            errorCount++;
            return;
        }
        if (!sym.allocated) {
            frameSize += 4;
            sym.offset = -frameSize;
            sym.allocated = true;
            gen("addi $sp, $sp, -4");
        }
    }

    public String getVariableAddress(String variable) {
        SymInfo sym = symtab.lookup(variable);
        if (sym == null) {
            System.err.println("Error: Variable '" + variable + "' no encontrada");
            errorCount++;
            return "0($sp)";
        }
        return sym.offset + "($fp)";
    }

    public String loadVariable(String variable) {
        String temp = newTemp();
        gen("lw " + temp + ", " + getVariableAddress(variable));
        return temp;
    }

    public void storeVariable(String variable, String register) {
        if (register == null || !register.startsWith("$")) {
            System.err.println("Error: Registro inválido");
            errorCount++;
            return;
        }
        gen("sw " + register + ", " + getVariableAddress(variable));
    }

    public String newLabel(String prefix) {
        return prefix + "_" + (labelCounter++);
    }

    public void saveCodeMIPS(String archivoSalida) {
        try (FileWriter writer = new FileWriter(archivoSalida)) {
            StringBuilder codigoCompleto = new StringBuilder();
            if (dataSectionGenerated) {
                codigoCompleto.append(dataSection.toString()).append("\n");
            }
            if (textSectionGenerated) {
                codigoCompleto.append(textSection.toString());
            }
            writer.write(codigoCompleto.toString());
            System.out.println("Código MIPS guardado en: " + archivoSalida);
        } catch (IOException e) {
            System.err.println("Error escribiendo archivo: " + e.getMessage());
            errorCount++;
        }
    }

    public void printCodeMIPS() {
        System.out.println("\n=== CÓDIGO MIPS GENERADO ===\n");

        if (dataSectionGenerated) {
            System.out.println(dataSection.toString());
        }

        if (textSectionGenerated) {
            System.out.println(textSection.toString());
        }
    }

    public SymTable getSymTable() {
            return symtab;
        }
    public ArbolSintactico getArbolSintactico() {
        return arbol;
    }

    public boolean hasErrors() {
        return errorCount > 0;
    }

    public int getErrorCount() { return errorCount; }

    public void syntax_error(Symbol cur_token) {
        errorCount++;
        System.err.println("ERROR SINTÁCTICO (Línea " + (cur_token.left + 1) +
                          ", Columna " + (cur_token.right + 1) + "): " +
                          "Token inesperado '" + cur_token.value + "'");
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        System.err.println("ERROR SINTÁCTICO IRRECUPERABLE - finalizando análisis");
    }


    parser(Lexer lex) {
            this.lex=lex;
            this.arbol = null;
        }
:}

/* Terminales */
terminal
    /* Palabras Reservadas */
    WORLD, LOCAL, DECIDE, OF, ELSE, END, LOOP, EXIT, WHEN, FOR, GIFT,
    NAVIDAD, COAL, SHOW, GET, RETURN, BREAK, ENDL,

    /* Tipos de Datos */
    INT, FLOAT, BOOL, CHAR, STRING,

    /* Literales */
    LITERAL_INTEGER, LITERAL_FLOAT, BOOL_LITERAL, CHAR_LITERAL, STRING_LITERAL,
    IDENTIFIER,

    /* Operadores Aritméticos */
    PLUS, MINUS, MULTIPLY, DIVIDE, INT_DIV, MODULO, POWER,
    INCREMENT, DECREMENT,

    /* Operadores Relacionales */
    LESS, LESS_EQUAL, GREATER, GREATER_EQUAL, EQUAL, NOT_EQUAL,

    /* Operadores Lógicos */
    AND, OR, NOT,

    /* Delimitadores */
    LBRACE, RBRACE, LPAREN, RPAREN, LBRACKET, RBRACKET,

    /* Puntuación */
    COMMA, ASSIGN, ARROW,

    /* error */
    ERROR;

/* No terminales */
non terminal program, functionList, mainFunction, functionDecl, arglist, funcall;
non terminal type, statement, statementList, block, expression, exprTerm;
non terminal logicalExpression, unaryExpression, relationalExpression, additiveExpression,
             multiplicativeExpression, powerExpression;
non terminal paramList, param, arrayDecl, arrayAccess, returnStmt;
non terminal varDecl, assignStmt, showStmt, getStmt, ifStmt, loopStmt, forStmt, forVarDec;
non terminal condition, conditionList, elsePart, arrayLiteral, arrayElements;
non terminal dimensions;

/* Precedencia */
precedence left OR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL;
precedence left LESS, LESS_EQUAL, GREATER, GREATER_EQUAL;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE, INT_DIV, MODULO;
precedence right POWER;
precedence right INCREMENT, DECREMENT;
precedence right NOT;

/* Regla de inicio */
start with program;

/* 1. PROGRAMA */
program ::= statementList:sl functionList:fl mainFunction:mf
    {:


        Nodo raizNodo = new Nodo("program");
        raizNodo.addHijo((Nodo)sl);
        raizNodo.addHijo((Nodo)fl);
        raizNodo.addHijo((Nodo)mf);
        arbol = new ArbolSintactico(raizNodo);
        initTextSection();
        RESULT = raizNodo;
    :}
    | statementList:sl functionList:fl
    {:


        if (!oneMain) {
            System.err.println("ERROR SEMÁNTICO: No se encontró la función main");
            errorCount++;
        }
        Nodo raizNodo = new Nodo("program");
        raizNodo.addHijo((Nodo)sl);
        raizNodo.addHijo((Nodo)fl);
        arbol = new ArbolSintactico(raizNodo);
        initTextSection();
        RESULT = raizNodo;
    :};

/* 2. FUNCIÓN PRINCIPAL */
mainFunction ::= COAL NAVIDAD
    {:
        frameSize = 0;
        currentTemp = 0;

        gen("navidad:");
        gen("addi $sp, $sp, -8");
        gen("sw $ra, 4($sp)");
        gen("sw $fp, 0($sp)");
        gen("move $fp, $sp");
    :}
    block:b
    {:
        if (oneMain) {
            System.err.println("ERROR SEMÁNTICO: Solo puede haber una función main");
            errorCount++;
        }
        oneMain = true;

        gen("move $sp, $fp");
        gen("lw $ra, 4($sp)");
        gen("lw $fp, 0($sp)");
        gen("addi $sp, $sp, 8");
        gen("jr $ra");

        Nodo resultado = new Nodo("mainFunction");
        resultado.addHijo(new Nodo("coal"));
        resultado.addHijo(new Nodo("navidad"));
        resultado.addHijo((Nodo)b);
        RESULT = resultado;
    :}
    | COAL NAVIDAD LPAREN RPAREN
          {:
              frameSize = 0;
              currentTemp = 0;

              gen("navidad:");
              gen("addi $sp, $sp, -8");
              gen("sw $ra, 4($sp)");
              gen("sw $fp, 0($sp)");
              gen("move $fp, $sp");
          :}
          block:b
          {:
              if (oneMain) {
                  System.err.println("ERROR SEMÁNTICO: Solo puede haber una función main");
                  errorCount++;
              }
              oneMain = true;

              gen("move $sp, $fp");
              gen("lw $ra, 4($sp)");
              gen("lw $fp, 0($sp)");
              gen("addi $sp, $sp, 8");
              gen("jr $ra");

              Nodo resultado = new Nodo("mainFunction");
              resultado.addHijo(new Nodo("coal"));
              resultado.addHijo(new Nodo("navidad"));
              resultado.addHijo((Nodo)b);
              RESULT = resultado;
          :};

/* 3. LISTA DE FUNCIONES */
functionList ::=
    {:
        Nodo resultado = new Nodo("functionList");
        RESULT = resultado;
    :}
    | functionList:fl functionDecl:fd
    {:
        Nodo resultado = new Nodo("functionList");
        resultado.addHijo((Nodo)fl);
        resultado.addHijo((Nodo)fd);
        RESULT = resultado;
    :};

/* 4. DECLARACIÓN DE FUNCIÓN */
functionDecl ::=
     GIFT type:t IDENTIFIER:id
     {:
        currentFunctionReturnType = ((Nodo)t).getTipo();
         if (!symtab.insert(new SymInfo((String)id, ((Nodo)t).getTipo(),
                                        SymKind.FUNCTION, idleft, idright))) {
             System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                              "): Función '" + id + "' ya declarada");
             errorCount++;
         }
         symtab.enterScope();
     :}
     LPAREN paramList:pl RPAREN block:b
     {:
        currentFunctionReturnType = null;
         symtab.exitScope();

         Nodo resultado = new Nodo("functionDecl");
         resultado.addHijo(new Nodo("gift"));
         resultado.addHijo((Nodo)t);

         Nodo idNode = new Nodo(id.toString());
         if (t != null && ((Nodo)t).getTipo() != null) {
             idNode.setTipo(((Nodo)t).getTipo());
         }
         resultado.addHijo(idNode);

         resultado.addHijo(new Nodo("¿"));
         resultado.addHijo((Nodo)pl);
         resultado.addHijo(new Nodo("?"));
         resultado.addHijo((Nodo)b);

         RESULT = resultado;
     :};

funcall ::= IDENTIFIER:id LPAREN arglist:al RPAREN
    {:
        SymInfo func = symtab.lookup((String)id);

        if (func == null) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Función '" + id + "' no declarada");
            errorCount++;
        } else if (func.kind != SymKind.FUNCTION) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): '" + id + "' no es una función");
            errorCount++;
        }

        Nodo resultado = new Nodo("funcall");
        Nodo idNode = new Nodo(id.toString());

        if (func != null) {
            idNode.setTipo(func.type);
            resultado.setTipo(func.type);
        }

        resultado.addHijo(idNode);
        resultado.addHijo(new Nodo("¿"));
        resultado.addHijo((Nodo)al);
        resultado.addHijo(new Nodo("?"));
        RESULT = resultado;
    :};
arglist ::=
    {:
        Nodo resultado = new Nodo("arglist");
        RESULT = resultado;
    :}
    | expression:e
    {:
        Nodo resultado = new Nodo("arglist");
        resultado.addHijo((Nodo)e);
        RESULT = resultado;
    :}
    | arglist:al COMMA expression:e
    {:
        Nodo resultado = new Nodo("arglist");
        Nodo alNodo = (Nodo)al;
        for (Nodo hijo : alNodo.hijos) {
            resultado.addHijo(hijo);
        }
        resultado.addHijo(new Nodo(","));
        resultado.addHijo((Nodo)e);
        RESULT = resultado;
    :};

/* 5. LISTA DE PARÁMETROS */
paramList ::=
    {:
        Nodo resultado = new Nodo("paramList");
        resultado.addHijo(new Nodo("¿"));
        resultado.addHijo(new Nodo("?"));
        RESULT = resultado;
    :}
    | param:p
    {:
        Nodo resultado = new Nodo("paramList");
        resultado.addHijo(new Nodo("¿"));
        resultado.addHijo((Nodo)p);
        resultado.addHijo(new Nodo("?"));
        RESULT = resultado;
    :}
    | paramList:pl COMMA param:p
    {:
        Nodo resultado = new Nodo("paramList");
        resultado.addHijo(new Nodo("¿"));

        Nodo plNodo = (Nodo)pl;
        for (Nodo hijo : plNodo.hijos) {
            if (!hijo.lexema.equals("¿") && !hijo.lexema.equals("?")) {
                resultado.addHijo(hijo);
            }
        }

        resultado.addHijo(new Nodo(","));
        resultado.addHijo((Nodo)p);
        resultado.addHijo(new Nodo("?"));
        RESULT = resultado;
    :};

/* 6. PARÁMETRO */
param ::= type:t IDENTIFIER:id
    {:
        Nodo resultado = new Nodo("param");
        resultado.addHijo((Nodo)t);

        Nodo idNode = new Nodo(id.toString());
        idNode.setTipo(((Nodo)t).getTipo());
        resultado.addHijo(idNode);

        if (!symtab.insert(new SymInfo((String)id, ((Nodo)t).getTipo(),
                                       SymKind.PARAM, idleft, idright))) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Parámetro '" + id + "' duplicado");
            errorCount++;
        }
        RESULT = resultado;
    :};

/* 7. TIPOS */
type ::= INT
    {:
        Nodo resultado = new Nodo("int");
        resultado.setTipo("int");
        RESULT = resultado;
    :}
    | FLOAT
    {:
        Nodo resultado = new Nodo("float");
        resultado.setTipo("float");
        RESULT = resultado;
    :}
    | BOOL
    {:
        Nodo resultado = new Nodo("bool");
        resultado.setTipo("bool");
        RESULT = resultado;
    :}
    | CHAR
    {:
        Nodo resultado = new Nodo("char");
        resultado.setTipo("char");
        RESULT = resultado;
    :}
    | STRING
    {:
        Nodo resultado = new Nodo("string");
        resultado.setTipo("string");
        RESULT = resultado;
    :};

/* 8. BLOQUE */
block ::= LBRACE
    {:
        symtab.enterScope();
    :}
    statementList:sl
    RBRACE
    {:
        symtab.exitScope();
        Nodo resultado = new Nodo("block");
        resultado.addHijo(new Nodo("¡"));

        if (sl != null) {
            resultado.addHijo((Nodo)sl);
        } else {
            Nodo emptyList = new Nodo("statementList");
            resultado.addHijo(emptyList);
        }

        resultado.addHijo(new Nodo("!"));
        RESULT = resultado;
    :};

/* 9. LISTA DE SENTENCIAS */
statementList ::=
    {:
        Nodo resultado = new Nodo("statementList");
        RESULT = resultado;
    :}
    | statementList:sl statement:s
    {:
        Nodo resultado = new Nodo("statementList");
        resultado.addHijo((Nodo)sl);
        resultado.addHijo((Nodo)s);
        RESULT = resultado;
    :};

/* 10. SENTENCIAS */
statement ::= varDecl:vd
    {:
        Nodo resultado = new Nodo("statement");
        resultado.addHijo((Nodo)vd);
        RESULT = resultado;
    :}
    | arrayDecl:ad
    {:
        Nodo resultado = new Nodo("statement");
        resultado.addHijo((Nodo)ad);
        RESULT = resultado;
    :}
    | assignStmt:as
    {:
        Nodo resultado = new Nodo("statement");
        resultado.addHijo((Nodo)as);
        RESULT = resultado;
    :}
    | showStmt:ss
    {:
        Nodo resultado = new Nodo("statement");
        resultado.addHijo((Nodo)ss);
        RESULT = resultado;
    :}
    | getStmt:gs
    {:
        Nodo resultado = new Nodo("statement");
        resultado.addHijo((Nodo)gs);
        RESULT = resultado;
    :}
    | ifStmt:is
    {:
        Nodo resultado = new Nodo("statement");
        resultado.addHijo((Nodo)is);
        RESULT = resultado;
    :}
    | loopStmt:ls
    {:
        Nodo resultado = new Nodo("statement");
        resultado.addHijo((Nodo)ls);
        RESULT = resultado;
    :}
    | forStmt:fs
    {:
        Nodo resultado = new Nodo("statement");
        resultado.addHijo((Nodo)fs);
        RESULT = resultado;
    :}
    | returnStmt:rs
    {:
        Nodo resultado = new Nodo("statement");
        resultado.addHijo((Nodo)rs);
        RESULT = resultado;
    :}
    | BREAK ENDL
    {:
        if (insideLoop <= 0) {
            System.err.println("ERROR SEMÁNTICO: break solo puede usarse dentro de loop o for");
            errorCount++;
        }

        Nodo resultado = new Nodo("statement");
        resultado.addHijo(new Nodo("break"));
        RESULT = resultado;
    :}
    | funcall:fc ENDL
    {:
        Nodo resultado = new Nodo("statement");
        resultado.addHijo((Nodo)fc);
        RESULT = resultado;
    :};

/* 11. DECLARACIÓN DE VARIABLE */
varDecl ::= LOCAL type:t IDENTIFIER:id ENDL
    {:
        Nodo resultado = new Nodo("varDecl");
        resultado.addHijo(new Nodo("local"));
        resultado.addHijo((Nodo)t);

        Nodo idNode = new Nodo(id.toString());
        idNode.setTipo(((Nodo)t).getTipo());
        resultado.addHijo(idNode);
        resultado.addHijo(new Nodo("endl"));

        if (!symtab.insert(new SymInfo((String)id, ((Nodo)t).getTipo(),
                                       SymKind.LOCAL_VAR, idleft, idright))) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Variable '" + id + "' ya declarada en este ámbito");
            errorCount++;
        }
        RESULT = resultado;
    :}
    | LOCAL type:t IDENTIFIER:id ASSIGN expression:e ENDL
    {:
        Nodo resultado = new Nodo("varDecl");
        resultado.addHijo(new Nodo("local"));
        resultado.addHijo((Nodo)t);

        Nodo idNode = new Nodo(id.toString());
        String tipoVar = ((Nodo)t).getTipo();
        idNode.setTipo(tipoVar);
        resultado.addHijo(idNode);
        resultado.addHijo(new Nodo("="));
        resultado.addHijo((Nodo)e);
        resultado.addHijo(new Nodo("endl"));
        Nodo nodoE = (Nodo)e;
        String tipoExpr = nodoE != null ? nodoE.getTipo() : null;

        if (tipoExpr == null || tipoExpr.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (eleft+1) + " Columna " + (eright+1) +
                             "): Expresión sin tipo en declaración de variable local");
            errorCount++;
        } else if (!tipoVar.equals(tipoExpr)) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): No se puede asignar " + tipoExpr +
                             " a variable local de tipo " + tipoVar);
            errorCount++;
        }

        if (!symtab.insert(new SymInfo((String)id, tipoVar,
                                       SymKind.LOCAL_VAR, idleft, idright))) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Variable '" + id + "' ya declarada en este ámbito");
            errorCount++;
        }
        allocateVariable((String)id);
        String tempExpr = nodoE.getTemp();
        storeVariable((String)id, tempExpr);

        RESULT = resultado;
    :}
    | WORLD type:t IDENTIFIER:id ENDL
    {:
        Nodo resultado = new Nodo("varDecl");
        resultado.addHijo(new Nodo("world"));
        resultado.addHijo((Nodo)t);

        Nodo idNode = new Nodo(id.toString());
        idNode.setTipo(((Nodo)t).getTipo());
        resultado.addHijo(idNode);
        resultado.addHijo(new Nodo("endl"));
        if (symtab.lenScopes() > 1) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                 "): Array global '" + id + "' Variables globales solo pueden declararse en el ámbito global");
            errorCount++;
        }
        if (!symtab.insert(new SymInfo((String)id, ((Nodo)t).getTipo(),
                                       SymKind.GLOBAL_VAR, idleft, idright))) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Variable global '" + id + "' ya declarada");
            errorCount++;
        }
        RESULT = resultado;
    :}
    | WORLD type:t IDENTIFIER:id ASSIGN expression:e ENDL
    {:
        Nodo resultado = new Nodo("varDecl");
        resultado.addHijo(new Nodo("world"));
        resultado.addHijo((Nodo)t);

        Nodo idNode = new Nodo(id.toString());
        String tipoVar = ((Nodo)t).getTipo();
        idNode.setTipo(tipoVar);
        resultado.addHijo(idNode);
        resultado.addHijo(new Nodo("="));
        resultado.addHijo((Nodo)e);
        resultado.addHijo(new Nodo("endl"));
        Nodo nodoE = (Nodo)e;
        String tipoExpr = nodoE != null ? nodoE.getTipo() : null;
        if (symtab.lenScopes() > 1) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Array global '" + id + "' Variables globales solo pueden declararse en el ámbito global");
            errorCount++;
        }
        if (tipoExpr == null || tipoExpr.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (eleft+1) + " Columna " + (eright+1) +
                             "): Expresión sin tipo en declaración de variable global");
            errorCount++;
        } else if (!tipoVar.equals(tipoExpr)) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): No se puede asignar " + tipoExpr +
                             " a variable global de tipo " + tipoVar);
            errorCount++;
        }

        if (!symtab.insert(new SymInfo((String)id, tipoVar,
                                       SymKind.GLOBAL_VAR, idleft, idright))) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Variable global '" + id + "' ya declarada");
            errorCount++;
        }
        RESULT = resultado;
    :};

/* 12. DECLARACIÓN DE ARRAY */
arrayDecl ::= LOCAL type:t IDENTIFIER:id dimensions:d ENDL
    {:
        Nodo resultado = new Nodo("arrayDecl");
        resultado.addHijo(new Nodo("local"));
        resultado.addHijo((Nodo)t);

        Nodo idNode = new Nodo(id.toString());
        idNode.setTipo(((Nodo)t).getTipo() + "[]");
        resultado.addHijo(idNode);
        resultado.addHijo((Nodo)d);
        resultado.addHijo(new Nodo("endl"));

        if (!symtab.insert(new SymInfo((String)id, ((Nodo)t).getTipo(),
                                       SymKind.LOCAL_ARRAY, idleft, idright))) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Array '" + id + "' ya declarado en este ámbito");
            errorCount++;
        }
        RESULT = resultado;
    :}
    | LOCAL type:t IDENTIFIER:id dimensions:d ASSIGN arrayLiteral:al ENDL
    {:
        Nodo resultado = new Nodo("arrayDecl");
        resultado.addHijo(new Nodo("local"));
        resultado.addHijo((Nodo)t);

        Nodo idNode = new Nodo(id.toString());
        idNode.setTipo(((Nodo)t).getTipo() + "[]");
        resultado.addHijo(idNode);
        resultado.addHijo((Nodo)d);
        resultado.addHijo(new Nodo("="));
        resultado.addHijo((Nodo)al);
        resultado.addHijo(new Nodo("endl"));

        if (!symtab.insert(new SymInfo((String)id, ((Nodo)t).getTipo(),
                                       SymKind.LOCAL_ARRAY, idleft, idright))) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Array '" + id + "' ya declarado en este ámbito");
            errorCount++;
        }
        int filas = d1;
        int columnas = d2;
        int size = filas * columnas * 4;

        gen("addi $sp, $sp, -" + size);

        RESULT = resultado;
    :}
    | WORLD type:t IDENTIFIER:id dimensions:d ENDL
    {:
        Nodo resultado = new Nodo("arrayDecl");
        resultado.addHijo(new Nodo("world"));
        resultado.addHijo((Nodo)t);

        Nodo idNode = new Nodo(id.toString());
        idNode.setTipo(((Nodo)t).getTipo() + "[]");
        resultado.addHijo(idNode);
        resultado.addHijo((Nodo)d);
        resultado.addHijo(new Nodo("endl"));
        if (symtab.lenScopes() > 1) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Array global '" + id + "' Variables globales solo pueden declararse en el ámbito global");
            errorCount++;
        }
        if (!symtab.insert(new SymInfo((String)id, ((Nodo)t).getTipo(),
                                       SymKind.GLOBAL_ARRAY, idleft, idright))) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Array global '" + id + "' ya declarado");
            errorCount++;
        }
        int filas = d1;
        int columnas = d2;
        int size = filas * columnas * 4;

        gen("addi $sp, $sp, -" + size);

        RESULT = resultado;
    :}
    | WORLD type:t IDENTIFIER:id dimensions:d ASSIGN arrayLiteral:al ENDL
    {:
        Nodo resultado = new Nodo("arrayDecl");
        resultado.addHijo(new Nodo("world"));
        resultado.addHijo((Nodo)t);

        Nodo idNode = new Nodo(id.toString());
        idNode.setTipo(((Nodo)t).getTipo() + "[]");
        resultado.addHijo(idNode);
        resultado.addHijo((Nodo)d);
        resultado.addHijo(new Nodo("="));
        resultado.addHijo((Nodo)al);
        resultado.addHijo(new Nodo("endl"));
        if (symtab.lenScopes() > 1) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Array global '" + id + "' Variables globales solo pueden declararse en el ámbito global");
            errorCount++;
        }
        if (!symtab.insert(new SymInfo((String)id, ((Nodo)t).getTipo(),
                                       SymKind.GLOBAL_ARRAY, idleft, idright))) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Array global '" + id + "' ya declarado");
            errorCount++;
        }
        int filas = d1;
        int columnas = d2;
        int size = filas * columnas * 4;

        gen("addi $sp, $sp, -" + size);

        RESULT = resultado;
    :};

/* 13. DIMENSIONES */
dimensions ::= LBRACKET LITERAL_INTEGER:lit1 RBRACKET LBRACKET LITERAL_INTEGER:lit2 RBRACKET
    {:
        Nodo resultado = new Nodo("dimensions");
        resultado.addHijo(new Nodo("["));
        resultado.addHijo(new Nodo(lit1.toString()));
        resultado.addHijo(new Nodo("]"));
        resultado.addHijo(new Nodo("["));
        resultado.addHijo(new Nodo(lit2.toString()));
        resultado.addHijo(new Nodo("]"));
        RESULT = resultado;
    :}
    | LBRACKET RBRACKET LBRACKET RBRACKET
    {:
        Nodo resultado = new Nodo("dimensions");
        resultado.addHijo(new Nodo("["));
        resultado.addHijo(new Nodo("]"));
        resultado.addHijo(new Nodo("["));
        resultado.addHijo(new Nodo("]"));
        RESULT = resultado;
    :};

/* 14. LITERAL DE ARRAY */
arrayLiteral ::= LBRACE LBRACE arrayElements:ae1 RBRACE COMMA LBRACE arrayElements:ae2 RBRACE RBRACE
    {:
        Nodo resultado = new Nodo("arrayLiteral");
        resultado.addHijo(new Nodo("¡"));
        resultado.addHijo(new Nodo("¡"));
        resultado.addHijo((Nodo)ae1);
        resultado.addHijo(new Nodo("!"));
        resultado.addHijo(new Nodo(","));
        resultado.addHijo(new Nodo("¡"));
        resultado.addHijo((Nodo)ae2);
        resultado.addHijo(new Nodo("!"));
        resultado.addHijo(new Nodo("!"));
        RESULT = resultado;
    :}
    | LBRACE arrayElements:ae RBRACE
    {:
        Nodo resultado = new Nodo("arrayLiteral");
        resultado.addHijo(new Nodo("¡"));
        resultado.addHijo((Nodo)ae);
        resultado.addHijo(new Nodo("!"));
        RESULT = resultado;
    :};

/* 15. ELEMENTOS DE ARRAY */
arrayElements ::= expression:e
    {:
        Nodo resultado = new Nodo("arrayElements");
        resultado.addHijo((Nodo)e);
        RESULT = resultado;
    :}
    | arrayElements:ae COMMA expression:e
    {:
        Nodo resultado = new Nodo("arrayElements");
        resultado.addHijo((Nodo)ae);
        resultado.addHijo(new Nodo(","));
        resultado.addHijo((Nodo)e);
        RESULT = resultado;
    :};

/* 16. ASIGNACIÓN */
assignStmt ::= IDENTIFIER:id ASSIGN expression:e ENDL
    {:
        SymInfo sym = symtab.lookup((String)id);
        Nodo nodoE = (Nodo)e;

        if (sym == null) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Variable '" + id + "' no declarada");
            errorCount++;
        } else {
            String tipoVar = sym.type;
            String tipoExpr = nodoE.getTipo();

            if (tipoExpr == null || tipoExpr.isEmpty()) {
                System.err.println("ERROR SEMÁNTICO (Línea " + (eleft+1) + " Columna " + (eright+1) +
                                 "): Expresión sin tipo en asignación");
                errorCount++;
            } else if (!tipoVar.equals(tipoExpr)) {
                System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                                 "): No se puede asignar " + tipoExpr +
                                 " a variable de tipo " + tipoVar);
                errorCount++;
            } else {

                String tempExpr = nodoE.getTemp();

                switch (tipoVar) {

                    case "int":
                    case "char":
                    case "boolean":
                    case "string":
                        // Todos se guardan como word
                        gen("sw " + tempExpr + ", " + getVariableAddress(id.toString()));
                        break;

                    case "float":
                        gen("s.s " + tempExpr + ", " + getVariableAddress(id.toString()));
                        break;

                    default:
                        System.err.println("ERROR SEMÁNTICO: tipo no soportado en asignación: " + tipoVar);
                        errorCount++;
                }
            }
        }

        Nodo resultado = new Nodo("assignStmt");
        resultado.addHijo(new Nodo(id.toString()));
        resultado.addHijo(new Nodo("="));
        resultado.addHijo((Nodo)e);
        resultado.addHijo(new Nodo("endl"));
        RESULT = resultado;
    :}
    | arrayAccess:aa ASSIGN expression:e ENDL
    {:
        Nodo nodoAa = (Nodo)aa;
        Nodo nodoE = (Nodo)e;

        String tipoArray = nodoAa.getTipo();
        String tipoExpr = nodoE.getTipo();

        if (tipoArray != null && tipoExpr != null && !tipoArray.equals(tipoExpr)) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (aaleft+1) + " Columna " + (aaright+1) +
                             "): No se puede asignar " + tipoExpr +
                             " a array de tipo " + tipoArray);
            errorCount++;
        }

        Nodo resultado = new Nodo("assignStmt");
        resultado.addHijo(nodoAa);
        resultado.addHijo(new Nodo("="));
        resultado.addHijo(nodoE);
        resultado.addHijo(new Nodo("endl"));
        RESULT = resultado;
    :};

/* 17. ACCESO A ARRAY */
arrayAccess ::= IDENTIFIER:id LBRACKET expression:e1 RBRACKET LBRACKET expression:e2 RBRACKET
    {:
        SymInfo sym = symtab.lookup((String)id);
        if (sym == null) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Array '" + id + "' no declarado");
            errorCount++;
        } else if (sym.kind != SymKind.LOCAL_ARRAY && sym.kind != SymKind.GLOBAL_ARRAY) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): '" + id + "' no es un array");
            errorCount++;
        }

        Nodo nodoE1 = (Nodo)e1;
        Nodo nodoE2 = (Nodo)e2;

        String tipoIndice1 = nodoE1.getTipo();
        String tipoIndice2 = nodoE2.getTipo();

        if (tipoIndice1 == null || tipoIndice1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (e1left+1) + " Columna " + (e1right+1) +
                             "): Primer índice sin tipo en acceso a array");
            errorCount++;
        } else if (!tipoIndice1.equals("int")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (e1left+1) + " Columna " + (e1right+1) +
                             "): Los índices de array solo pueden ser int. Se encontró: " + tipoIndice1);
            errorCount++;
        }

        if (tipoIndice2 == null || tipoIndice2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (e2left+1) + " Columna " + (e2right+1) +
                             "): Segundo índice sin tipo en acceso a array");
            errorCount++;
        } else if (!tipoIndice2.equals("int")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (e2left+1) + " Columna " + (e2right+1) +
                             "): Los índices de array solo pueden ser int. Se encontró: " + tipoIndice2);
            errorCount++;
        }

        Nodo resultado = new Nodo("access");
        resultado.addHijo(new Nodo(id.toString()));
        resultado.addHijo(new Nodo("["));
        resultado.addHijo(nodoE1);
        resultado.addHijo(new Nodo("]"));
        resultado.addHijo(new Nodo("["));
        resultado.addHijo(nodoE2);
        resultado.addHijo(new Nodo("]"));

        if (sym != null) {
            resultado.setTipo(sym.type);
        }

        RESULT = resultado;
    :};

/* 18. SHOW */
showStmt ::= SHOW LPAREN expression:e RPAREN ENDL
    {:
        Nodo nodoE = (Nodo)e;
        String tipoExpr = nodoE.getTipo();

        if (tipoExpr == null || tipoExpr.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (eleft+1) + " Columna " + (eright+1) +
                             "): Expresión sin tipo en show");
            errorCount++;
        } else if (!tipoExpr.equals("int") && !tipoExpr.equals("float") &&
                   !tipoExpr.equals("char") && !tipoExpr.equals("string") &&
                   !tipoExpr.equals("bool")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (eleft+1) + " Columna " + (eright+1) +
                             "): show solo acepta int, float, char, string o bool. Se encontró: " + tipoExpr);
            errorCount++;
       } else {

                  String temp = nodoE.getTemp();

                  if (temp != null) {
                      if (tipoExpr.equals("int")) {
                          gen("move $a0, " + temp);
                          gen("li $v0, 1");
                          gen("syscall");

                      } else if (tipoExpr.equals("float")) {
                          gen("mov.s $f12, " + temp);
                          gen("li $v0, 2");
                          gen("syscall");

                      } else if (tipoExpr.equals("char")) {
                          gen("move $a0, " + temp);
                          gen("li $v0, 11");
                          gen("syscall");

                      } else if (tipoExpr.equals("string")) {
                          gen("move $a0, " + temp);
                          gen("li $v0, 4");
                          gen("syscall");
                      } else if (tipoExpr.equals("bool")) {
                          gen("move $a0, " + temp);
                          gen("li $v0, 1");
                          gen("syscall");
                      }

                      gen("li $a0, 10");
                      gen("li $v0, 11");
                      gen("syscall");
                  }
              }

        Nodo resultado = new Nodo("showStmt");
        resultado.addHijo(new Nodo("show"));
        resultado.addHijo(new Nodo("¿"));
        resultado.addHijo(nodoE);
        resultado.addHijo(new Nodo("?"));
        resultado.addHijo(new Nodo("endl"));
        RESULT = resultado;
    :};

/* 19. GET */
getStmt ::= GET LPAREN IDENTIFIER:id RPAREN ENDL
    {:
        Nodo resultado = new Nodo("getStmt");
        resultado.addHijo(new Nodo("get"));
        resultado.addHijo(new Nodo("¿"));
        resultado.addHijo(new Nodo(id.toString()));
        resultado.addHijo(new Nodo("?"));
        resultado.addHijo(new Nodo("endl"));

        // get ¿ ? devuelve
        SymInfo sym = symtab.lookup(id.toString());
        if (sym == null) {
                System.err.println("ERROR SEMÁNTICO: variable '" + id + "' no encontrada");
                errorCount++;
            } else {
                // Asignar tipo al nodo (int o float según la variable)
                resultado.setTipo(sym.type);

                // Reservar espacio en stack si no se ha hecho
                allocateVariable(id.toString());

                // Generar código MIPS según tipo
                if (sym.type.equals("int")) {
                    // Leer entero
                    gen("li $v0, 5");                // syscall para leer int
                    gen("syscall");
                    gen("sw $v0, " + getVariableAddress(id.toString())); // guardar en variable
                } else if (sym.type.equals("float")) {
                    // Leer float
                    gen("li $v0, 6");                // syscall para leer float
                    gen("syscall");
                    gen("s.s $f0, " + getVariableAddress(id.toString())); // guardar en variable
                } else {
                    System.err.println("ERROR SEMÁNTICO: tipo no soportado para get: " + sym.type);
                    errorCount++;
                }
            }
        RESULT = resultado;
    :};

/* 20. DECIDE OF */
ifStmt ::= DECIDE OF conditionList:cl elsePart:ep END DECIDE ENDL
{:
    Nodo nodoIf = new Nodo("decide");

    String endLabel = newLabel("decide_end");

    Nodo listaCondiciones = (Nodo) cl;

    /* recorrer condiciones */
    for (int i = 0; i < listaCondiciones.hijos.size(); i++) {

        Nodo condicion = listaCondiciones.hijos.get(i);

        Nodo expr  = condicion.hijos.get(0); // expression
        Nodo block = condicion.hijos.get(2); // block

        String nextLabel = newLabel("decide_next");

        /* el temp de la expresión YA existe */
        String condTemp = expr.getTemp();

        /* if (!cond) goto siguiente condición */
        gen("beqz " + condTemp + ", " + nextLabel);

        /* el bloque genera su propio código */
        gen("j " + endLabel);

        /* siguiente condición */
        gen(nextLabel + ":");
    }

    /* ELSE (si existe) */
    Nodo elseNodo = (Nodo) ep;
    if (elseNodo != null && !elseNodo.hijos.isEmpty()) {
        Nodo elseBlock = elseNodo.hijos.get(2); // block
        // el código del bloque ya fue generado
    }

    gen(endLabel + ":");

    /* árbol sintáctico */
    nodoIf.addHijo(new Nodo("decide"));
    nodoIf.addHijo(new Nodo("of"));
    nodoIf.addHijo(listaCondiciones);
    nodoIf.addHijo((Nodo) ep);
    nodoIf.addHijo(new Nodo("end"));
    nodoIf.addHijo(new Nodo("decide"));
    nodoIf.addHijo(new Nodo("endl"));

    RESULT = nodoIf;
:};


/* 21. LISTA DE CONDICIONES */
conditionList ::= condition:c
    {:
        Nodo resultado = new Nodo("conditionList");
        resultado.addHijo((Nodo)c);
        RESULT = resultado;
    :}
    | conditionList:cl condition:c
    {:
        Nodo resultado = new Nodo("conditionList");
        resultado.addHijo((Nodo)cl);
        resultado.addHijo((Nodo)c);
        RESULT = resultado;
    :};

/* 22. CONDICIÓN */
condition ::= expression:e ARROW block:b
    {:
        Nodo nodoE = (Nodo)e;
        String tipoExpr = nodoE.getTipo();

        if (tipoExpr == null || tipoExpr.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (eleft+1) + " Columna " + (eright+1) +
                             "): Condición sin tipo en decide of");
            errorCount++;
        } else if (!tipoExpr.equals("bool")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (eleft+1) + " Columna " + (eright+1) +
                             "): La condición de decide of debe ser bool. Se encontró: " + tipoExpr);
            errorCount++;
        }

        Nodo resultado = new Nodo("condition");
        resultado.addHijo(nodoE);
        resultado.addHijo(new Nodo("->"));
        resultado.addHijo((Nodo)b);
        RESULT = resultado;
    :};

/* 23. PARTE ELSE */
elsePart ::=
    {:
        Nodo resultado = new Nodo("elsePart");
        RESULT = resultado;
    :}
    | ELSE ARROW block:b
    {:
        Nodo resultado = new Nodo("elsePart");
        resultado.addHijo(new Nodo("else"));
        resultado.addHijo(new Nodo("->"));
        resultado.addHijo((Nodo)b);
        RESULT = resultado;
    :};

/* 24. LOOP */
loopStmt ::= LOOP
    {:
        insideLoop++;
    :}
    statementList:sl EXIT WHEN expression:e ENDL END LOOP ENDL
    {:
        Nodo nodoE = (Nodo)e;
        String tipoExpr = nodoE.getTipo();

        if (tipoExpr == null || tipoExpr.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (eleft+1) + " Columna " + (eright+1) +
                             "): Condición de salida sin tipo en loop");
            errorCount++;
        } else if (!tipoExpr.equals("bool")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (eleft+1) + " Columna " + (eright+1) +
                             "): La condición de exit when debe ser bool. Se encontró: " + tipoExpr);
            errorCount++;
        }
        insideLoop--;

        Nodo resultado = new Nodo("loopStmt");
        resultado.addHijo(new Nodo("loop"));
        resultado.addHijo((Nodo)sl);
        resultado.addHijo(new Nodo("exit"));
        resultado.addHijo(new Nodo("when"));
        resultado.addHijo(nodoE);
        resultado.addHijo(new Nodo("endl"));
        resultado.addHijo(new Nodo("end"));
        resultado.addHijo(new Nodo("loop"));
        resultado.addHijo(new Nodo("endl"));
        RESULT = resultado;
    :};

/* 25. FOR  */
forStmt ::= FOR LPAREN
    {:
        symtab.enterScope();
        insideLoop++;
    :}
    forVarDec:fvd
    {:
        String labelStart = newLabel("for_cond");
        String labelEnd = newLabel("for_end");
        currentForLabels = new String[]{labelStart, labelEnd};
        gen(labelStart + ":");
    :}
    expression:e1 ENDL
    {:
        Nodo nodoE1 = (Nodo)e1;
        String tipoCondicion = nodoE1.getTipo();

        if (tipoCondicion == null || tipoCondicion.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (e1left+1) + " Columna " + (e1right+1) +
                             "): Condición del for sin tipo");
            errorCount++;
        } else if (!tipoCondicion.equals("bool")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (e1left+1) + " Columna " + (e1right+1) +
                             "): La condición del for debe ser bool. Se encontró: " + tipoCondicion);
            errorCount++;
        }

        String tempCondicion = nodoE1.getTemp();
        gen("beqz " + tempCondicion + ", " + currentForLabels[1]);
        forIncrementCodeStart = textSection.length();
    :}
    expression:e2 RPAREN
    {:
        int incrementCodeEnd = textSection.length();
        String incrementCode = textSection.substring(forIncrementCodeStart, incrementCodeEnd);
        textSection.delete(forIncrementCodeStart, incrementCodeEnd);
        parser.savedIncrementCode = incrementCode;
        forBlockCodeStart = textSection.length();
    :}
    block:b
    {:
        gen("# Increment");
        textSection.append(savedIncrementCode);
        gen("j " + currentForLabels[0]);
        gen(currentForLabels[1] + ":");

        insideLoop--;
        symtab.exitScope();

        currentForLabels = null;
        savedIncrementCode = null;

        Nodo resultado = new Nodo("forStmt");
        resultado.addHijo(new Nodo("for"));
        resultado.addHijo(new Nodo("¿"));
        resultado.addHijo((Nodo)fvd);
        resultado.addHijo((Nodo)e1);
        resultado.addHijo(new Nodo("endl"));
        resultado.addHijo((Nodo)e2);
        resultado.addHijo(new Nodo("?"));
        resultado.addHijo((Nodo)b);
        RESULT = resultado;
    :};

/* 26. DECLARACIÓN EN FOR  */
forVarDec ::= type:t IDENTIFIER:id ASSIGN expression:e ENDL
    {:
        Nodo nodoE = (Nodo)e;
        String tipoVar = ((Nodo)t).getTipo();
        String tipoExpr = nodoE.getTipo();

        if (tipoExpr == null || tipoExpr.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (eleft+1) + " Columna " + (eright+1) +
                             "): Expresión sin tipo en inicialización del for");
            errorCount++;
        } else if (!tipoVar.equals(tipoExpr)) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): No se puede asignar " + tipoExpr +
                             " a variable de tipo " + tipoVar + " en for");
            errorCount++;
        }

        Nodo resultado = new Nodo("forVarDec");
        resultado.addHijo((Nodo)t);

        Nodo idNode = new Nodo(id.toString());
        idNode.setTipo(tipoVar);
        resultado.addHijo(idNode);
        resultado.addHijo(new Nodo("="));
        resultado.addHijo(nodoE);
        resultado.addHijo(new Nodo("endl"));

        if (!symtab.insert(new SymInfo((String)id, tipoVar,
                                       SymKind.FOR_VAR, idleft, idright))) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Variable de FOR '" + id + "' ya declarada");
            errorCount++;
        }
        RESULT = resultado;
    :};

/* 27. RETURN */
returnStmt ::= RETURN expression:e ENDL
    {:
        Nodo nodoE = (Nodo)e;
        String tipoExpr = nodoE.getTipo();

        if (currentFunctionReturnType != null &&
            !currentFunctionReturnType.equals(tipoExpr)) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (eleft+1) + " Columna " + (eright+1) +
                             "): return esperaba tipo " + currentFunctionReturnType +
                             ", se encontró: " + tipoExpr);
            errorCount++;
        }

        Nodo resultado = new Nodo("returnStmt");
        resultado.addHijo(new Nodo("return"));
        resultado.addHijo(nodoE);
        resultado.addHijo(new Nodo("endl"));
        RESULT = resultado;
    :};

/* 28. TÉRMINOS DE EXPRESIÓN */
exprTerm ::= LITERAL_INTEGER:lit
    {:
        Nodo resultado = new Nodo(lit.toString());
        resultado.setTipo("int");

        String temp = newTemp();
        gen("li " + temp + ", " + lit);
        resultado.setTemp(temp);

        RESULT = resultado;
    :}
    | LITERAL_FLOAT:lit
    {:
        Nodo resultado = new Nodo(lit.toString());
        resultado.setTipo("float");

        String temp = newTemp();
        gen("li.s " + temp + ", " + lit);

        resultado.setTemp(temp);
        RESULT = resultado;
    :}
    | BOOL_LITERAL:lit
    {:
        Nodo resultado = new Nodo(lit.toString());
        resultado.setTipo("bool");

        String temp = newTemp();

        if (lit.toString().equals("true")) {
            gen("li " + temp + ", 1");
        } else {
            gen("li " + temp + ", 0");
        }

        resultado.setTemp(temp);

        RESULT = resultado;
    :}
    | CHAR_LITERAL:lit
    {:
        String lex = lit.toString();
        char value = 'a';

        if(lex.length() == 3) { // para chars solitos como 'a' o '%'
            value = lex.charAt(1);
        } else if(lex.length() == 4 && lex.charAt(1) == '\\'){ // para char con escape como '\n'
            switch (lex.charAt(2)){
                case 'n': value = '\n'; break;
                case 't': value = '\t'; break;
                case '\'': value = '\''; break;
                case '\\': value = '\\'; break; // se guardan así, pero después al hacer int(value) se vuelven a su valor ASCII
            }
        }else {
            System.err.println("ERROR SEMÁNTICO: CHAR_LITERAL inválido: " + lex);
            value = 0;
            errorCount++;
        }
        String temp = newTemp();
        gen("li " + temp + ", " + (int)value);

        Nodo resultado = new Nodo(lit.toString());
        resultado.setTipo("char");
        RESULT = resultado;
    :}
    | STRING_LITERAL:lit
    {:
        Nodo resultado = new Nodo(lit.toString());
        resultado.setTipo("string");

        String label = "_str_" + labelCounter++;
        String litValue = lit.toString();

        if (litValue.startsWith("\"") && litValue.endsWith("\"")) {
            genData(label, ".asciiz " + litValue);
        } else {
            genData(label, ".asciiz \"" + litValue + "\"");
        }

        String temp = newTemp();
        gen("la " + temp + ", " + label);

        resultado.setTemp(temp);
        RESULT = resultado;
    :}
    | IDENTIFIER:id
    {:
        Nodo resultado = new Nodo(id.toString());
        SymInfo sym = symtab.lookup((String)id);
        if (sym == null) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             "): Variable '" + id + "' no declarada");
            errorCount++;
        } else {
            resultado.setTipo(sym.type);
            String temp = loadVariable((String)id);
            resultado.setTemp(temp);
        }
        RESULT = resultado;
    :}
    | arrayAccess:aa
    {:
        RESULT = aa;
    :}
    | GET LPAREN RPAREN
    {:
        Nodo resultado = new Nodo("get");
        resultado.addHijo(new Nodo("¿"));
        resultado.addHijo(new Nodo("?"));
        RESULT = resultado;
    :}
    | LPAREN expression:e RPAREN
    {:
        Nodo nodoE = (Nodo)e;
        Nodo resultado = new Nodo("¿?");
        resultado.addHijo(new Nodo("¿"));
        resultado.addHijo(nodoE);
        resultado.addHijo(new Nodo("?"));
        resultado.setTipo(nodoE.getTipo());
        resultado.setTemp(nodoE.getTemp());
        RESULT = resultado;
    :}
    | funcall:fc
   {:
       RESULT = fc;
   :};

/* 29. EXPRESIÓN */
expression ::= logicalExpression:le
    {:
        RESULT = le;
    :};

/* Expresiones lógicas */
logicalExpression ::= relationalExpression:re
    {:
        RESULT = re;
    :}
    | logicalExpression:le OR relationalExpression:re
    {:
        Nodo nodoLe = (Nodo)le;
        Nodo nodoRe = (Nodo)re;

        String tipo1 = nodoLe.getTipo();
        String tipo2 = nodoRe.getTipo();

        if (tipo1 == null || tipo1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (leleft+1) + " Columna " + (leright+1) + "): Operando izquierdo sin tipo en OR");
            errorCount++;
            tipo1 = "error";
        }
        if (tipo2 == null || tipo2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (releft+1) + " Columna " + (reright+1) + "): Operando derecho sin tipo en OR");
            errorCount++;
            tipo2 = "error";
        }

        if (!tipo1.equals("bool") && !tipo1.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (leleft+1) + " Columna " + (leright+1) +
                             "): El operador OR (~) solo acepta bool. Se encontró: " + tipo1);
            errorCount++;
        }

        if (!tipo2.equals("bool") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (releft+1) + " Columna " + (reright+1) +
                             "): El operador OR (~) solo acepta bool. Se encontró: " + tipo2);
            errorCount++;
        }

        Nodo resultado = new Nodo("~");
        resultado.setTipo("bool");
        resultado.addHijo(nodoLe);
        resultado.addHijo(nodoRe);

        String temp1 = nodoLe.getTemp();
        String temp2 = nodoRe.getTemp();
        String tempResult = newTemp();

        gen("or " + tempResult + ", " + temp1 + ", " + temp2);

        resultado.setTemp(tempResult);
        RESULT = resultado;

        RESULT = resultado;
    :}
    | logicalExpression:le AND relationalExpression:re
    {:
        Nodo nodoLe = (Nodo)le;
        Nodo nodoRe = (Nodo)re;

        String tipo1 = nodoLe.getTipo();
        String tipo2 = nodoRe.getTipo();

        if (tipo1 == null || tipo1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (leleft+1) + " Columna " + (leright+1) + "): Operando izquierdo sin tipo en AND");
            errorCount++;
            tipo1 = "error";
        }
        if (tipo2 == null || tipo2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (releft+1) + " Columna " + (reright+1) + "): Operando derecho sin tipo en AND");
            errorCount++;
            tipo2 = "error";
        }

        if (!tipo1.equals("bool") && !tipo1.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (leleft+1) + " Columna " + (leright+1) +
                             "): El operador AND (@) solo acepta bool. Se encontró: " + tipo1);
            errorCount++;
        }

        if (!tipo2.equals("bool") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (releft+1) + " Columna " + (reright+1) +
                             "): El operador AND (@) solo acepta bool. Se encontró: " + tipo2);
            errorCount++;
        }

        Nodo resultado = new Nodo("@");
        resultado.setTipo("bool");
        resultado.addHijo(nodoLe);
        resultado.addHijo(nodoRe);

        String temp1 = nodoLe.getTemp();
        String temp2 = nodoRe.getTemp();
        String tempResult = newTemp();

        gen("and " + tempResult + ", " + temp1 + ", " + temp2);

        resultado.setTemp(tempResult);
        RESULT = resultado;
    :};

/* Expresiones relacionales */
relationalExpression ::= additiveExpression:ae
    {:
        RESULT = ae;
    :}
    | additiveExpression:ae1 EQUAL additiveExpression:ae2
    {:
        Nodo nodoAe1 = (Nodo)ae1;
        Nodo nodoAe2 = (Nodo)ae2;

        String tipo1 = nodoAe1.getTipo();
        String tipo2 = nodoAe2.getTipo();

        if (tipo1 == null || tipo1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae1right+1) + "): Operando izquierdo sin tipo en comparación");
            errorCount++;
            tipo1 = "error";
        }
        if (tipo2 == null || tipo2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae2left+1) + " Columna " + (ae2right+1) + "): Operando derecho sin tipo en comparación");
            errorCount++;
            tipo2 = "error";
        }

        if (!tipo1.equals(tipo2) && !tipo1.equals("error") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae1right+1) +
                             "): No se puede comparar " + tipo1 + " con " + tipo2);
            errorCount++;
        }

        Nodo resultado = new Nodo("==");
        resultado.setTipo("bool");
        resultado.addHijo(nodoAe1);
        resultado.addHijo(nodoAe2);

        String temp1 = nodoAe1.getTemp();
        String temp2 = nodoAe2.getTemp();
        String tempResult = newTemp();

        if (tipo1.equals("int") || tipo1.equals("bool") || tipo1.equals("char")) {
            gen("xor " + tempResult + ", " + temp1 + ", " + temp2);
            gen("sltu " + tempResult + ", " + tempResult + ", 1");
        } else if (tipo1.equals("float")) {
            String labelTrue = newLabel("eq_true");
            gen("c.eq.s " + temp1 + ", " + temp2);
            gen("li " + tempResult + ", 0");
            gen("bc1f " + labelTrue);
            gen("li " + tempResult + ", 1");
            gen(labelTrue + ":");
        }

        resultado.setTemp(tempResult);
        RESULT = resultado;
    :}
    | additiveExpression:ae1 NOT_EQUAL additiveExpression:ae2
    {:
        Nodo nodoAe1 = (Nodo)ae1;
        Nodo nodoAe2 = (Nodo)ae2;

        String tipo1 = nodoAe1.getTipo();
        String tipo2 = nodoAe2.getTipo();

        if (tipo1 == null || tipo1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae1right+1) + "): Operando izquierdo sin tipo en comparación");
            errorCount++;
            tipo1 = "error";
        }
        if (tipo2 == null || tipo2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae2left+1) + " Columna " + (ae2right+1) +"): Operando derecho sin tipo en comparación");
            errorCount++;
            tipo2 = "error";
        }

        if (!tipo1.equals(tipo2) && !tipo1.equals("error") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae1right+1) +
                             "): No se puede comparar " + tipo1 + " con " + tipo2);
            errorCount++;
        }

        Nodo resultado = new Nodo("!=");
        resultado.setTipo("bool");
        resultado.addHijo(nodoAe1);
        resultado.addHijo(nodoAe2);

        String temp1 = nodoAe1.getTemp();
        String temp2 = nodoAe2.getTemp();
        String tempResult = newTemp();

        if (tipo1.equals("int") || tipo1.equals("bool") || tipo1.equals("char")) {
            String tempXor = newTemp();
            gen("xor " + tempXor + ", " + temp1 + ", " + temp2);
            gen("sltu " + tempResult + ", $zero, " + tempXor);
        } else if (tipo1.equals("float")) {
            String labelTrue = newLabel("ne_true");
            String labelEnd = newLabel("ne_end");

            gen("c.eq.s " + temp1 + ", " + temp2);
            gen("bc1t " + labelTrue);
            gen("li " + tempResult + ", 1");
            gen("b " + labelEnd);
            gen(labelTrue + ":");
            gen("li " + tempResult + ", 0");
            gen(labelEnd + ":");
        }

        resultado.setTemp(tempResult);

        RESULT = resultado;
    :}
    | additiveExpression:ae1 LESS additiveExpression:ae2
    {:
        Nodo nodoAe1 = (Nodo)ae1;
        Nodo nodoAe2 = (Nodo)ae2;

        String tipo1 = nodoAe1.getTipo();
        String tipo2 = nodoAe2.getTipo();

        if (tipo1 == null || tipo1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae1right+1) + "): Operando izquierdo sin tipo");
            errorCount++;
            tipo1 = "error";
        }
        if (tipo2 == null || tipo2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae2left+1) + " Columna " + (ae2right+1) + "): Operando derecho sin tipo");
            errorCount++;
            tipo2 = "error";
        }

        if (!tipo1.equals("int") && !tipo1.equals("float") && !tipo1.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae1right+1) +
                             "): El operador < solo acepta int o float. Se encontró: " + tipo1);
            errorCount++;
        }

        if (!tipo2.equals("int") && !tipo2.equals("float") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae2left+1) + " Columna " + (ae2right+1) +
                             "): El operador < solo acepta int o float. Se encontró: " + tipo2);
            errorCount++;
        }

        if (!tipo1.equals(tipo2) && !tipo1.equals("error") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae1right+1) +
                             "): Tipos incompatibles en <. Operando 1: " + tipo1 +
                             ", Operando 2: " + tipo2);
            errorCount++;
        }

        Nodo resultado = new Nodo("<");
        resultado.setTipo("bool");
        resultado.addHijo(nodoAe1);
        resultado.addHijo(nodoAe2);

        String temp1 = nodoAe1.getTemp();
        String temp2 = nodoAe2.getTemp();
        String tempResult = newTemp();

        if (tipo1.equals("int")) {
            gen("slt " + tempResult + ", " + temp1 + ", " + temp2);
        } else if (tipo1.equals("float")) {
            String labelTrue = newLabel("lt_true");
            String labelEnd = newLabel("lt_end");

            gen("c.lt.s " + temp1 + ", " + temp2);
            gen("li " + tempResult + ", 0");
            gen("bc1f " + labelTrue);
            gen("li " + tempResult + ", 1");
            gen(labelTrue + ":");
        }

        resultado.setTemp(tempResult);
        RESULT = resultado;
    :}
    | additiveExpression:ae1 LESS_EQUAL additiveExpression:ae2
    {:
        Nodo nodoAe1 = (Nodo)ae1;
        Nodo nodoAe2 = (Nodo)ae2;

        String tipo1 = nodoAe1.getTipo();
        String tipo2 = nodoAe2.getTipo();

        if (tipo1 == null || tipo1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae1right+1) + "): Operando izquierdo sin tipo");
            errorCount++;
            tipo1 = "error";
        }
        if (tipo2 == null || tipo2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae2left+1) + " Columna " + (ae2right+1) + "): Operando derecho sin tipo");
            errorCount++;
            tipo2 = "error";
        }

        if (!tipo1.equals("int") && !tipo1.equals("float") && !tipo1.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae1right+1) +
                             "): El operador <= solo acepta int o float. Se encontró: " + tipo1);
            errorCount++;
        }

        if (!tipo2.equals("int") && !tipo2.equals("float") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae2left+1) + " Columna " + (ae2right+1) +
                             "): El operador <= solo acepta int o float. Se encontró: " + tipo2);
            errorCount++;
        }

        if (!tipo1.equals(tipo2) && !tipo1.equals("error") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae2right+1) +
                             "): Tipos incompatibles en <=. Operando 1: " + tipo1 +
                             ", Operando 2: " + tipo2);
            errorCount++;
        }

        Nodo resultado = new Nodo("<=");
        resultado.setTipo("bool");
        resultado.addHijo(nodoAe1);
        resultado.addHijo(nodoAe2);

        String temp1 = nodoAe1.getTemp();
        String temp2 = nodoAe2.getTemp();
        String tempResult = newTemp();

        if (tipo1.equals("int")) {
            String tempGT = newTemp();
            gen("slt " + tempGT + ", " + temp2 + ", " + temp1);
            gen("xori " + tempResult + ", " + tempGT + ", 1");
        } else if (tipo1.equals("float")) {
            String labelTrue = newLabel("le_true");

            gen("c.le.s " + temp1 + ", " + temp2);
            gen("li " + tempResult + ", 0");
            gen("bc1f " + labelTrue);
            gen("li " + tempResult + ", 1");
            gen(labelTrue + ":");
        }

        resultado.setTemp(tempResult);
        RESULT = resultado;
    :}
    | additiveExpression:ae1 GREATER additiveExpression:ae2
    {:
        Nodo nodoAe1 = (Nodo)ae1;
        Nodo nodoAe2 = (Nodo)ae2;

        String tipo1 = nodoAe1.getTipo();
        String tipo2 = nodoAe2.getTipo();

        if (tipo1 == null || tipo1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae1right+1) + "): Operando izquierdo sin tipo");
            errorCount++;
            tipo1 = "error";
        }
        if (tipo2 == null || tipo2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae2left+1) + " Columna " + (ae2right+1) + "): Operando derecho sin tipo");
            errorCount++;
            tipo2 = "error";
        }

        if (!tipo1.equals("int") && !tipo1.equals("float") && !tipo1.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae1right+1) +
                             "): El operador > solo acepta int o float. Se encontró: " + tipo1);
            errorCount++;
        }

        if (!tipo2.equals("int") && !tipo2.equals("float") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae2left+1) + " Columna " + (ae2right+1) +
                             "): El operador > solo acepta int o float. Se encontró: " + tipo2);
            errorCount++;
        }

        if (!tipo1.equals(tipo2) && !tipo1.equals("error") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae2right+1) +
                             "): Tipos incompatibles en >. Operando 1: " + tipo1 +
                             ", Operando 2: " + tipo2);
            errorCount++;
        }

        Nodo resultado = new Nodo(">");
        resultado.setTipo("bool");
        resultado.addHijo(nodoAe1);
        resultado.addHijo(nodoAe2);

        String temp1 = nodoAe1.getTemp();
        String temp2 = nodoAe2.getTemp();
        String tempResult = newTemp();

        if (tipo1.equals("int")) {
            gen("slt " + tempResult + ", " + temp2 + ", " + temp1);
        } else if (tipo1.equals("float")) {
            String labelTrue = newLabel("gt_true");

            gen("c.lt.s " + temp2 + ", " + temp1);
            gen("li " + tempResult + ", 0");
            gen("bc1f " + labelTrue);
            gen("li " + tempResult + ", 1");
            gen(labelTrue + ":");
        }

        resultado.setTemp(tempResult);
        RESULT = resultado;
    :}
    | additiveExpression:ae1 GREATER_EQUAL additiveExpression:ae2
    {:
        Nodo nodoAe1 = (Nodo)ae1;
        Nodo nodoAe2 = (Nodo)ae2;

        String tipo1 = nodoAe1.getTipo();
        String tipo2 = nodoAe2.getTipo();

        if (tipo1 == null || tipo1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae1right+1) + "): Operando izquierdo sin tipo");
            errorCount++;
            tipo1 = "error";
        }
        if (tipo2 == null || tipo2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae2left+1) + " Columna " + (ae2right+1) + "): Operando derecho sin tipo");
            errorCount++;
            tipo2 = "error";
        }

        if (!tipo1.equals("int") && !tipo1.equals("float") && !tipo1.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae1right+1) +
                             "): El operador >= solo acepta int o float. Se encontró: " + tipo1);
            errorCount++;
        }

        if (!tipo2.equals("int") && !tipo2.equals("float") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae2left+1) + " Columna " + (ae2right+1) +
                             "): El operador >= solo acepta int o float. Se encontró: " + tipo2);
            errorCount++;
        }

        if (!tipo1.equals(tipo2) && !tipo1.equals("error") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ae1left+1) + " Columna " + (ae1right+1) +
                             "): Tipos incompatibles en >=. Operando 1: " + tipo1 +
                             ", Operando 2: " + tipo2);
            errorCount++;
        }

        Nodo resultado = new Nodo(">=");
        resultado.setTipo("bool");
        resultado.addHijo(nodoAe1);
        resultado.addHijo(nodoAe2);

        String temp1 = nodoAe1.getTemp();
        String temp2 = nodoAe2.getTemp();
        String tempResult = newTemp();

        if (tipo1.equals("int")) {
            gen("slt " + tempResult + ", " + temp1 + ", " + temp2);
            gen("xori " + tempResult + ", " + tempResult + ", 1");
        } else if (tipo1.equals("float")) {
            String labelTrue = newLabel("ge_true");

            gen("c.le.s " + temp2 + ", " + temp1);
            gen("li " + tempResult + ", 0");
            gen("bc1f " + labelTrue);
            gen("li " + tempResult + ", 1");
            gen(labelTrue + ":");
        }

        resultado.setTemp(tempResult);

        RESULT = resultado;
    :};

/* Expresiones aritméticas */
additiveExpression ::= multiplicativeExpression:me
    {:
        RESULT = me;
    :}
    | additiveExpression:ae PLUS multiplicativeExpression:me
    {:
        Nodo nodoAe = (Nodo)ae;
        Nodo nodoMe = (Nodo)me;

        String tipo1 = nodoAe.getTipo();
        String tipo2 = nodoMe.getTipo();

        if (tipo1 == null || tipo1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (aeleft+1) +  " Columna " + (aeright+1) + "): Operando izquierdo sin tipo en suma");
            errorCount++;
            tipo1 = "error";
        }
        if (tipo2 == null || tipo2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (meleft+1) + " Columna " + (meright+1) + "): Operando derecho sin tipo en suma");
            errorCount++;
            tipo2 = "error";
        }

        if (!tipo1.equals("int") && !tipo1.equals("float") && !tipo1.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (aeleft+1) + " Columna " + (aeright+1) +
                             "): El operador + solo acepta int o float. Se encontró: " + tipo1);
            errorCount++;
        }

        if (!tipo2.equals("int") && !tipo2.equals("float") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (meleft+1) + " Columna " + (meright+1) +
                             "): El operador + solo acepta int o float. Se encontró: " + tipo2);
            errorCount++;
        }

        if (!tipo1.equals(tipo2) && !tipo1.equals("error") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (aeleft+1) + " Columna " + (aeright+1) +
                             "): Tipos incompatibles en suma. Operando 1: " + tipo1 +
                             ", Operando 2: " + tipo2);
            errorCount++;
        }

        Nodo resultado = new Nodo("+");
        resultado.setTipo(tipo1.equals("error") ? "error" : tipo1);
        resultado.addHijo(nodoAe);
        resultado.addHijo(nodoMe);

        String tempResult = newTemp();

        // Operando izquierdo
        String temp1;
        SymInfo sym1 = symtab.lookup(nodoAe.lexema);
        if (sym1 != null) {
            // Es una variable → recargar desde memoria
            temp1 = newTemp();
            gen("lw " + temp1 + ", " + getVariableAddress(nodoAe.lexema));
        } else {
            // Es un literal o expresión
            temp1 = nodoAe.getTemp();
        }

        // Operando derecho
        String temp2;
        SymInfo sym2 = symtab.lookup(nodoMe.lexema);
        if (sym2 != null) {
            temp2 = newTemp();
            gen("lw " + temp2 + ", " + getVariableAddress(nodoMe.lexema));
        } else {
            temp2 = nodoMe.getTemp();
        }

        // Generar suma
        if (tipo1.equals("int")) {
            gen("add " + tempResult + ", " + temp1 + ", " + temp2);
        } else if (tipo1.equals("float")) {
            gen("add.s " + tempResult + ", " + temp1 + ", " + temp2);
        }

        resultado.setTemp(tempResult);


        RESULT = resultado;
    :}
    | additiveExpression:ae MINUS multiplicativeExpression:me
    {:
        Nodo nodoAe = (Nodo)ae;
        Nodo nodoMe = (Nodo)me;

        String tipo1 = nodoAe.getTipo();
        String tipo2 = nodoMe.getTipo();

        if (tipo1 == null || tipo1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (aeleft+1) + " Columna " + (aeright+1) + "): Operando izquierdo sin tipo en resta");
            errorCount++;
            tipo1 = "error";
        }
        if (tipo2 == null || tipo2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (meleft+1) + " Columna " + (meright+1) +"): Operando derecho sin tipo en resta");
            errorCount++;
            tipo2 = "error";
        }

        if (!tipo1.equals("int") && !tipo1.equals("float") && !tipo1.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (aeleft+1) + " Columna " + (aeright+1) +
                             "): El operador - solo acepta int o float. Se encontró: " + tipo1);
            errorCount++;
        }

        if (!tipo2.equals("int") && !tipo2.equals("float") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (meleft+1) + " Columna " + (meright+1) +
                             "): El operador - solo acepta int o float. Se encontró: " + tipo2);
            errorCount++;
        }

        if (!tipo1.equals(tipo2) && !tipo1.equals("error") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (aeleft+1) + " Columna " + (aeright+1) +
                             "): Tipos incompatibles en resta. Operando 1: " + tipo1 +
                             ", Operando 2: " + tipo2);
            errorCount++;
        }

        Nodo resultado = new Nodo("-");
        resultado.setTipo(tipo1.equals("error") ? "error" : tipo1);
        resultado.addHijo(nodoAe);
        resultado.addHijo(nodoMe);

        String temp1 = nodoAe.getTemp();
        String temp2 = nodoMe.getTemp();
        String tempResult = newTemp();

        if (tipo1.equals("int")) {
            gen("sub " + tempResult + ", " + temp1 + ", " + temp2);
        } else if (tipo1.equals("float")) {
            gen("sub.s " + tempResult + ", " + temp1 + ", " + temp2);
        }

        resultado.setTemp(tempResult);
        RESULT = resultado;
    :};


multiplicativeExpression ::= powerExpression:pe
    {:
        RESULT = pe;
    :}
    | multiplicativeExpression:me MULTIPLY powerExpression:pe
    {:
        Nodo nodoMe = (Nodo)me;
        Nodo nodoPe = (Nodo)pe;

        String tipo1 = nodoMe.getTipo();
        String tipo2 = nodoPe.getTipo();

        if (tipo1 == null || tipo1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (meleft+1) + " Columna " + (meright+1) + "): Operando izquierdo sin tipo en multiplicación");
            errorCount++;
            tipo1 = "error";
        }
        if (tipo2 == null || tipo2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (peleft+1) + " Columna " + (peright+1) + "): Operando derecho sin tipo en multiplicación");
            errorCount++;
            tipo2 = "error";
        }

        if (!tipo1.equals("int") && !tipo1.equals("float") && !tipo1.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (meleft+1) + " Columna " + (meright+1) +
                             "): El operador * solo acepta int o float. Se encontró: " + tipo1);
            errorCount++;
        }

        if (!tipo2.equals("int") && !tipo2.equals("float") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (peleft+1) + " Columna " + (peright+1) +
                             "): El operador * solo acepta int o float. Se encontró: " + tipo2);
            errorCount++;
        }

        if (!tipo1.equals(tipo2) && !tipo1.equals("error") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (meleft+1) + " Columna " + (meright+1) +
                             "): Tipos incompatibles en multiplicación. Operando 1: " + tipo1 +
                             ", Operando 2: " + tipo2);
            errorCount++;
        }

        Nodo resultado = new Nodo("*");
        resultado.setTipo(tipo1.equals("error") ? "error" : tipo1);
        resultado.addHijo(nodoMe);
        resultado.addHijo(nodoPe);

        String temp1 = nodoMe.getTemp();
        String temp2 = nodoPe.getTemp();
        String tempResult = newTemp();

        if (tipo1.equals("int")) {
            gen("mul " + tempResult + ", " + temp1 + ", " + temp2);
        } else if (tipo1.equals("float")) {
            gen("mul.s " + tempResult + ", " + temp1 + ", " + temp2);
        }

        resultado.setTemp(tempResult);
        RESULT = resultado;
    :}
    | multiplicativeExpression:me DIVIDE powerExpression:pe
    {:
        Nodo nodoMe = (Nodo)me;
        Nodo nodoPe = (Nodo)pe;

        String tipo1 = nodoMe.getTipo();
        String tipo2 = nodoPe.getTipo();

        if (tipo1 == null || tipo1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (meleft+1) + " Columna " + (meright+1) + "): Operando izquierdo sin tipo en división");
            errorCount++;
            tipo1 = "error";
        }
        if (tipo2 == null || tipo2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (peleft+1) + " Columna " + (peright+1) + "): Operando derecho sin tipo en división");
            errorCount++;
            tipo2 = "error";
        }

        if (!tipo1.equals("int") && !tipo1.equals("float") && !tipo1.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (meleft+1) + " Columna " + (meright+1) +
                             "): El operador / solo acepta int o float. Se encontró: " + tipo1);
            errorCount++;
        }

        if (!tipo2.equals("int") && !tipo2.equals("float") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (peleft+1) + " Columna " + (peright+1) +
                             "): El operador / solo acepta int o float. Se encontró: " + tipo2);
            errorCount++;
        }

        if (!tipo1.equals(tipo2) && !tipo1.equals("error") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (meleft+1) + " Columna " + (meright+1) +
                             "): Tipos incompatibles en división. Operando 1: " + tipo1 +
                             ", Operando 2: " + tipo2);
            errorCount++;
        }

        Nodo resultado = new Nodo("/");
        resultado.setTipo(tipo1.equals("error") ? "error" : tipo1);
        resultado.addHijo(nodoMe);
        resultado.addHijo(nodoPe);

        String temp1 = nodoMe.getTemp();
        String temp2 = nodoPe.getTemp();
        String tempResult = newTemp();

        if (tipo1.equals("int")) {
            gen("div " + temp1 + ", " + temp2);
            gen("mflo " + tempResult);
        } else if (tipo1.equals("float")) {
            gen("div.s " + tempResult + ", " + temp1 + ", " + temp2);
        }

        resultado.setTemp(tempResult);

        RESULT = resultado;
    :}
    | multiplicativeExpression:me INT_DIV powerExpression:pe
    {:
        Nodo nodoMe = (Nodo)me;
        Nodo nodoPe = (Nodo)pe;

        String tipo1 = nodoMe.getTipo();
        String tipo2 = nodoPe.getTipo();

        if (tipo1 == null || tipo1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (meleft+1) + " Columna " + (meright+1) + "): Operando izquierdo sin tipo en división entera");
            errorCount++;
            tipo1 = "error";
        }
        if (tipo2 == null || tipo2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (peleft+1) + " Columna " + (peright+1) + "): Operando derecho sin tipo en división entera");
            errorCount++;
            tipo2 = "error";
        }

        if (!tipo1.equals("int") && !tipo1.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (meleft+1) + " Columna " + (meright+1) +
                             "): El operador // solo acepta int. Se encontró: " + tipo1);
            errorCount++;
        }

        if (!tipo2.equals("int") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (peleft+1) + " Columna " + (peright+1) +
                             "): El operador // solo acepta int. Se encontró: " + tipo2);
            errorCount++;
        }

        Nodo resultado = new Nodo("//");
        resultado.setTipo("int");
        resultado.addHijo(nodoMe);
        resultado.addHijo(nodoPe);

        String temp1 = nodoMe.getTemp();
        String temp2 = nodoPe.getTemp();
        String tempResult = newTemp();

        gen("div " + temp1 + ", " + temp2);
        gen("mflo " + tempResult);

        resultado.setTemp(tempResult);

        RESULT = resultado;
    :}
    | multiplicativeExpression:me MODULO powerExpression:pe
    {:
        Nodo nodoMe = (Nodo)me;
        Nodo nodoPe = (Nodo)pe;

        String tipo1 = nodoMe.getTipo();
        String tipo2 = nodoPe.getTipo();

        if (tipo1 == null || tipo1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (meleft+1) + " Columna " + (meright+1) + "): Operando izquierdo sin tipo en módulo");
            errorCount++;
            tipo1 = "error";
        }
        if (tipo2 == null || tipo2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (peleft+1) + " Columna " + (peright+1) +"): Operando derecho sin tipo en módulo");
            errorCount++;
            tipo2 = "error";
        }

        if (!tipo1.equals("int") && !tipo1.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (meleft+1) + " Columna " + (meright+1) +
                             "): El operador % solo acepta int. Se encontró: " + tipo1);
            errorCount++;
        }

        if (!tipo2.equals("int") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (peleft+1) + " Columna " + (peright+1) +
                             "): El operador % solo acepta int. Se encontró: " + tipo2);
            errorCount++;
        }

        Nodo resultado = new Nodo("%");
        resultado.setTipo("int");
        resultado.addHijo(nodoMe);
        resultado.addHijo(nodoPe);

        String temp1 = nodoMe.getTemp();
        String temp2 = nodoPe.getTemp();
        String tempResult = newTemp();

        gen("div " + temp1 + ", " + temp2);
        gen("mfhi " + tempResult);

        resultado.setTemp(tempResult);

        RESULT = resultado;
    :};


powerExpression ::= unaryExpression:ue
    {:
        RESULT = ue;
    :}
    | unaryExpression:ue POWER powerExpression:pe
    {:
        Nodo nodoUe = (Nodo)ue;
        Nodo nodoPe = (Nodo)pe;

        String tipo1 = nodoUe.getTipo();
        String tipo2 = nodoPe.getTipo();

        if (tipo1 == null || tipo1.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ueleft+1) + " Columna " + (ueright+1) + "): Base sin tipo en potencia");
            errorCount++;
            tipo1 = "error";
        }
        if (tipo2 == null || tipo2.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (peleft+1) + " Columna " + (peright+1) + "): Exponente sin tipo en potencia");
            errorCount++;
            tipo2 = "error";
        }

        if (!tipo1.equals("int") && !tipo1.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ueleft+1) + " Columna " + (ueright+1) +
                             "): El operador ^ solo acepta int. Se encontró base: " + tipo1);
            errorCount++;
        }

        if (!tipo2.equals("int") && !tipo2.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (peleft+1) + " Columna " + (peright+1) +
                             "): El operador ^ solo acepta int. Se encontró exponente: " + tipo2);
            errorCount++;
        }

        Nodo resultado = new Nodo("^");
        resultado.setTipo("int");
        resultado.addHijo(nodoUe);
        resultado.addHijo(nodoPe);

        String temp1 = nodoUe.getTemp();
        String temp2 = nodoPe.getTemp();
        String tempResult = newTemp();
        String tempCounter = newTemp();

        int labelNum = currentTemp++;
        String labelLoop = "pow_loop_" + labelNum;
        String labelEnd = "pow_end_" + labelNum;

        gen("li " + tempResult + ", 1");
        gen("beqz " + temp2 + ", " + labelEnd);
        gen("move " + tempCounter + ", " + temp2);
        gen(labelLoop + ":");
        gen("mul " + tempResult + ", " + tempResult + ", " + temp1);
        gen("addi " + tempCounter + ", " + tempCounter + ", -1");
        gen("bgtz " + tempCounter + ", " + labelLoop);
        gen(labelEnd + ":");

        resultado.setTemp(tempResult);
        RESULT = resultado;
    :};

/* Expresiones unarias */
unaryExpression ::= exprTerm:et
    {:
        RESULT = et;
    :}
    | MINUS unaryExpression:ue
    {:
        Nodo nodoUe = (Nodo)ue;
        String tipo = nodoUe.getTipo();

        if (tipo == null || tipo.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ueleft+1) + " Columna " + (ueright+1) +
                             "): Operando sin tipo en negación");
            errorCount++;
            tipo = "error";
        }

        if (!tipo.equals("int") && !tipo.equals("float") && !tipo.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ueleft+1) + " Columna " + (ueright+1) +
                             "): El operador - (negación) solo acepta int o float. Se encontró: " + tipo);
            errorCount++;
        }

        Nodo resultado = new Nodo("minus");
        resultado.setTipo(tipo);
        resultado.addHijo(nodoUe);

        String temp = nodoUe.getTemp();
        String tempResult = newTemp();

        if (tipo.equals("int")) {
            gen("sub " + tempResult + ", $zero, " + temp);
        } else if (tipo.equals("float")) {
            gen("neg.s " + tempResult + ", " + temp);
        }

        resultado.setTemp(tempResult);
        RESULT = resultado;
    :}
    | NOT unaryExpression:ue
    {:
        Nodo nodoUe = (Nodo)ue;
        String tipo = nodoUe.getTipo();

        if (tipo == null || tipo.isEmpty()) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ueleft+1) + " Columna " + (ueright+1) +
                             "): Operando sin tipo en NOT");
            errorCount++;
            tipo = "error";
        }

        if (!tipo.equals("bool") && !tipo.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (ueleft+1) + " Columna " + (ueright+1) +
                             "): El operador NOT (Σ) solo acepta bool. Se encontró: " + tipo);
            errorCount++;
        }

        Nodo resultado = new Nodo("not");
        resultado.setTipo("bool");
        resultado.addHijo(nodoUe);

        String temp = nodoUe.getTemp();
        String tempResult = newTemp();

        gen("sltu " + tempResult + ", " + temp + ", 1");

        resultado.setTemp(tempResult);
        RESULT = resultado;
    :}
    | INCREMENT IDENTIFIER:id
    {:
        SymInfo sym = symtab.lookup((String)id);
        if (sym == null) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             ", Columna " + (idright+1) +
                             "): Variable '" + id + "' no declarada");
            errorCount++;
        }

        String tipo = sym != null ? sym.type : "error";

        if (!tipo.equals("int") && !tipo.equals("float") && !tipo.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             ", Columna " + (idright+1) +
                             "): El operador ++ solo acepta int o float. Se encontró: " + tipo);
            errorCount++;
        }

        Nodo resultado = new Nodo("increment");
        resultado.setTipo(tipo);

        Nodo idNode = new Nodo(id.toString());
        idNode.setTipo(tipo);
        resultado.addHijo(idNode);

        String temp = loadVariable((String)id);
        String tempResult = newTemp();

        if (tipo.equals("int")) {
            gen("addi " + tempResult + ", " + temp + ", 1");
            storeVariable((String)id, tempResult);
        } else if (tipo.equals("float")) {
            String tempOne = newTemp();
            gen("li.s " + tempOne + ", 1.0");
            gen("add.s " + tempResult + ", " + temp + ", " + tempOne);
            storeVariable((String)id, tempResult);
        }

        resultado.setTemp(tempResult);
        RESULT = resultado;
    :}
    | DECREMENT IDENTIFIER:id
    {:
        SymInfo sym = symtab.lookup((String)id);
        if (sym == null) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             ", Columna " + (idright+1) +
                             "): Variable '" + id + "' no declarada");
            errorCount++;
        }

        String tipo = sym != null ? sym.type : "error";

        if (!tipo.equals("int") && !tipo.equals("float") && !tipo.equals("error")) {
            System.err.println("ERROR SEMÁNTICO (Línea " + (idleft+1) + " Columna " + (idright+1) +
                             ", Columna " + (idright+1) +
                             "): El operador -- solo acepta int o float. Se encontró: " + tipo);
            errorCount++;
        }

        Nodo resultado = new Nodo("decrement");
        resultado.setTipo(tipo);

        Nodo idNode = new Nodo(id.toString());
        idNode.setTipo(tipo);
        resultado.addHijo(idNode);

        String temp = loadVariable((String)id);
        String tempResult = newTemp();

        if (tipo.equals("int")) {
            gen("addi " + tempResult + ", " + temp + ", -1");
            storeVariable((String)id, tempResult);
        } else if (tipo.equals("float")) {
            String tempOne = newTemp();
            gen("li.s " + tempOne + ", 1.0");
            gen("sub.s " + tempResult + ", " + temp + ", " + tempOne);
            storeVariable((String)id, tempResult);
        }

        resultado.setTemp(tempResult);
        RESULT = resultado;
    :};

