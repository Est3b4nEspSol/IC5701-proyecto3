package generated;
import java_cup.runtime.*;
import Sintactico.*;

parser code {:
    Lexer lex;
    SymTable symtab = new SymTable();
    ArbolSintactico arbol;


    public ArbolSintactico getArbolSintactico() {
        return arbol;
    }

    public SymTable getSymTable() {
            return symtab;
        }
    @Override
    public void unrecovered_syntax_error(Symbol s) throws Exception {
    System.err.println(
      "ERROR SINTÁCTICO IRRECUPERABLE → token=" + s.sym +
      " valor=" + s.value +
      " línea=" + (s.left + 1) +
      " columna=" + (s.right + 1)
    );
    throw new Exception("Error sintáctico irrecuperable");
    }
    @Override
    public void report_error(String message, Object info) {
      Symbol s = (Symbol) info;
      System.err.println(
        "ERROR SINTÁCTICO → " + message +
        " token=" + s.sym +
        " valor=" + s.value +
        " línea=" + (s.left + 1) +
        " columna=" + (s.right + 1)
      );
    }
    parser(Lexer lex){ this.lex=lex; }
:}

/* Terminales (sin UMINUS) */
terminal
    /* Palabras Reservadas */
    WORLD, LOCAL, DECIDE, OF, ELSE, END, LOOP, EXIT, WHEN, FOR, GIFT,
    NAVIDAD, COAL, SHOW, GET, RETURN, BREAK, ENDL,

    /* Tipos de Datos */
    INT, FLOAT, BOOL, CHAR, STRING,

    /* Literales */
    LITERAL_INTEGER, LITERAL_FLOAT, BOOL_LITERAL, CHAR_LITERAL, STRING_LITERAL,
    IDENTIFIER,

    /* Operadores Aritméticos */
    PLUS, MINUS, MULTIPLY, DIVIDE, INT_DIV, MODULO, POWER,
    INCREMENT, DECREMENT,

    /* Operadores Relacionales */
    LESS, LESS_EQUAL, GREATER, GREATER_EQUAL, EQUAL, NOT_EQUAL,

    /* Operadores Lógicos */
    AND, OR, NOT,

    /* Delimitadores */
    LBRACE, RBRACE, LPAREN, RPAREN, LBRACKET, RBRACKET,

    /* Puntuación */
    COMMA, ASSIGN, ARROW,

    /* error */
    ERROR;

/* No terminales */
non terminal program, functionList, mainFunction, functionDecl;
non terminal type, statement, statementList, block, expression, exprTerm, op, uniop;
non terminal paramList, param, arrayDecl, arrayAccess, returnStmt;
non terminal varDecl, assignStmt, showStmt, getStmt, ifStmt, loopStmt, forStmt, forVarDec;
non terminal condition, conditionList, elsePart, arrayLiteral, arrayElements;
non terminal dimensions, access1D, access2D;

/* Precedencia (sin UMINUS) */
precedence left OR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL;
precedence left LESS, LESS_EQUAL, GREATER, GREATER_EQUAL;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE, INT_DIV, MODULO;
precedence right POWER;
precedence right INCREMENT, DECREMENT;
precedence right NOT;

/* Regla de inicio */
start with program;

/* ============ PRODUCCIONES ============ */

/* 1. PROGRAMA */
program ::= statementList functionList mainFunction;

/* 2. FUNCIÓN PRINCIPAL */
mainFunction ::= COAL NAVIDAD block;

/* 3. LISTA DE FUNCIONES */
functionList ::= /* vacío */
                | functionList functionDecl;

/* 4. DECLARACIÓN DE FUNCIÓN */
functionDecl ::=
    GIFT type IDENTIFIER:id
    {:
            // id es el VALOR del token (String)
            // El Symbol está en $idleft / $idright
            symtab.insert(
                new SymInfo(
                    (String) id,
                    SymKind.FUNCTION,
                    idleft,
                    idright
                )
            );
            symtab.enterScope();
        :}
    LPAREN paramList RPAREN block returnStmt
    {:
        symtab.exitScope();
    :};
/* 5. LISTA DE PARÁMETROS */
paramList ::= /* vacío */
             | param
             | paramList COMMA param;

param ::= type IDENTIFIER:id
    {:
        symtab.insert(
            new SymInfo(
                (String) id,
                SymKind.PARAM,
                idleft,
                idright
            )
        );
    :};


/* 6. TIPOS */
type ::= INT
       | FLOAT
       | BOOL
       | CHAR
       | STRING;

/* 7. BLOQUE */
block ::= LBRACE
    {:
        symtab.enterScope();
    :}
    statementList
    RBRACE
    {:
        symtab.exitScope();
    :};


/* 8. LISTA DE SENTENCIAS */
statementList ::= /* vacío */
                 | statementList statement;

/* 9. SENTENCIAS */
statement ::= error
            | varDecl
            | arrayDecl
            | assignStmt
            | showStmt
            | getStmt
            | ifStmt
            | loopStmt
            | forStmt
            | returnStmt
            | BREAK;

/* 10. DECLARACIÓN DE VARIABLE */
varDecl ::= LOCAL type IDENTIFIER:id ENDL
    {:
        symtab.insert(
            new SymInfo(
                (String) id,
                SymKind.LOCAL_VAR,
                idleft,
                idright
            )
        );
    :}
    | LOCAL type IDENTIFIER:id ASSIGN expression ENDL
    {:
       symtab.insert(
           new SymInfo(
               (String) id,
               SymKind.LOCAL_VAR,
               idleft,
               idright
           )
       );
    :}
    | WORLD type IDENTIFIER:id ENDL
    {:
        symtab.insert(
            new SymInfo(
                (String) id,
                SymKind.GLOBAL_VAR,
                idleft,
                idright
            )
        );
:}
    | WORLD type IDENTIFIER:id ASSIGN expression ENDL
    {:
        symtab.insert(
            new SymInfo(
                (String) id,
                SymKind.GLOBAL_VAR,
                idleft,
                idright
            )
        );
    :};



/* 11. DECLARACIÓN DE ARRAY */
arrayDecl ::=
      LOCAL type IDENTIFIER:id dimensions ENDL
      {:
          symtab.insert(
              new SymInfo(
                  (String) id,
                  SymKind.LOCAL_ARRAY,
                  idleft,
                  idright
              )
          );
      :}
    | LOCAL type IDENTIFIER:id dimensions ASSIGN arrayLiteral ENDL
      {:
            symtab.insert(
                new SymInfo(
                    (String) id,
                    SymKind.LOCAL_ARRAY,
                    idleft,
                    idright
                )
            );
      :}
    | WORLD type IDENTIFIER:id dimensions ENDL
      {:
          symtab.insert(
              new SymInfo(
                  (String) id,
                  SymKind.GLOBAL_ARRAY,
                  idleft,
                  idright
              )
          );
      :}
    | WORLD type IDENTIFIER:id dimensions ASSIGN arrayLiteral ENDL
      {:
            symtab.insert(
                new SymInfo(
                    (String) id,
                    SymKind.GLOBAL_ARRAY,
                    idleft,
                    idright
                )
            );
      :};


dimensions ::= LBRACKET LITERAL_INTEGER RBRACKET LBRACKET LITERAL_INTEGER RBRACKET
             | LBRACKET RBRACKET LBRACKET RBRACKET;

/* 12. LITERAL DE ARRAY */
arrayLiteral ::= LBRACE LBRACE arrayElements RBRACE COMMA LBRACE arrayElements RBRACE RBRACE
               | LBRACE arrayElements RBRACE;

arrayElements ::= expression
                | arrayElements COMMA expression;

/* 13. ASIGNACIÓN */
assignStmt ::= IDENTIFIER ASSIGN expression ENDL
             | arrayAccess ASSIGN expression ENDL;

/* 14. ACCESO A ARRAY */
access1D ::= IDENTIFIER LBRACKET expression RBRACKET;
access2D ::= access1D LBRACKET expression RBRACKET;
arrayAccess ::= access1D | access2D;

/* 15. SHOW */
showStmt ::= SHOW LPAREN expression RPAREN ENDL;

/* 16. GET */
getStmt ::= GET LPAREN RPAREN ENDL;

/* 17. DECIDE OF */
ifStmt ::= DECIDE OF conditionList elsePart END DECIDE ENDL;

conditionList ::= condition
                | conditionList condition;

condition ::= expression ARROW block;

elsePart ::= /* vacío */
           | ELSE ARROW block;

/* 18. LOOP */
loopStmt ::= LOOP statementList EXIT WHEN expression ENDL END LOOP ENDL;

/* 19. FOR */
forStmt ::= FOR LPAREN forVarDec expression ENDL expression RPAREN block;
forVarDec ::= type IDENTIFIER:id ASSIGN expression ENDL
                  {:
                     symtab.insert(
                         new SymInfo(
                             (String) id,
                             SymKind.LOCAL_VAR,
                             idleft,
                             idright
                         )
                     );
                  :};


/* 20. RETURN */
returnStmt ::= RETURN expression ENDL;

/* 21. TÉRMINOS DE EXPRESIÓN */
exprTerm ::= LITERAL_INTEGER
           | LITERAL_FLOAT
           | BOOL_LITERAL
           | CHAR_LITERAL
           | STRING_LITERAL
           | IDENTIFIER
           | arrayAccess
           | GET LPAREN RPAREN
           | LPAREN expression RPAREN;

/* 22. EXPRESIÓN (con precedencia implícita) */
expression ::= exprTerm
             | uniop expression
             | expression op expression;

uniop ::= MINUS | NOT | INCREMENT | DECREMENT;
op ::= POWER | MULTIPLY | DIVIDE | INT_DIV | MODULO | PLUS | MINUS | LESS | LESS_EQUAL
        | GREATER | GREATER_EQUAL | EQUAL | NOT_EQUAL | AND | OR;
